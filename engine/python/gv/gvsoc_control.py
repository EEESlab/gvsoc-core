#
# Copyright (C) 2021 GreenWaves Technologies
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

from telnetlib import Telnet

class Telnet_proxy(object):
    """
    A class used to control GVSOC through the telnet proxy

    Attributes
    ----------
    host : str
        a string giving the hostname where the proxy is running
    port : int
        the port where to connect
    """

    def __init__(self, host: str = 'localhost', port: int = 42951):
        self.telnet = Telnet(host, port)

    def trace_add(self, trace: str):
        """Enable a trace.

        Parameters
        ----------
        trace : str
            A regular expression used to enable traces
        """

        self.telnet.write(('trace add %s\n' % trace).encode('ascii'))

    def trace_remove(self, trace: str):
        """Disable a trace.

        Parameters
        ----------
        trace : str
            A regular expression used to disable traces
        """

        self.telnet.write(('trace remove %s\n' % trace).encode('ascii'))

    def trace_level(self, level: str):
        """Changes the trace level.

        Parameters
        ----------
        level : str
            The trace level, can be "error", "warning", "info", "debug" or "trace"
        """

        self.telnet.write(('trace level %s\n' % level).encode('ascii'))

    def event_add(self, event: str):
        """Enable an event.

        Parameters
        ----------
        event : str
            A regular expression used to enable events
        """

        self.telnet.write(('event add %s\n' % event).encode('ascii'))

    def event_remove(self, event: str):
        """Disable a trace.

        Parameters
        ----------
        event : str
            A regular expression used to enable events
        """

        self.telnet.write(('event remove %s\n' % event).encode('ascii'))

    def run(self, duration: int = None):
        """Starts execution.

        Parameters
        ----------
        duration : int, optional
            Specify the duration of the execution in picoseconds (will execute forever by default)
        """

        if duration is not None:
            self.telnet.write(('step %d\n' % duration).encode('ascii'))
        else:
            self.telnet.write('run\n'.encode('ascii'))

        self.telnet.read_until(b"\n")

    def quit(self, status: int = 0):
        """Exit simulation.

        Parameters
        ----------
        duration : int, optional
            Specify the status value.
        """

        self.telnet.write(('quit %d\n' % status).encode('ascii'))


    def _handle_err(self, error, error_str=None):
        if error != 0:
            if error_str is None:
                raise RuntimeError("Proxy command failed with status %s" % error)
            else:
                raise RuntimeError("Proxy command failed with message: %s" % error_str)


    def _get_retval(self):
        result = self.telnet.read_until(b"\n").decode('ascii')
        error = 0
        error_str = None
        for arg in result.split(';'):
            name, value = arg.split('=')
            if name == 'err':
                error = int(value)
            elif name == 'msg':
                error_str = value

        self._handle_err(error, error_str)

        if error != 0:
            if error_str is None:
                raise RuntimeError("Proxy command failed with status %s" % error)
            else:
                raise RuntimeError("Proxy command failed with message: %s" % error_str)


    def _get_component(self, path):
            self.telnet.write(('get_component %s\n' % path).encode('ascii'))
            result = self.telnet.read_until(b"\n")
            return result.decode('ascii').replace('\n', '')


class Router(object):
    """
    A class used to inject memory accesses into a router

    Attributes
    ----------
    proxy : Telnet_proxy
        The proxy object. This class will use it to send command to GVSOC through the proxy connection.
    path : string, optional
        The path to the router in the architecture.
    """

    def __init__(self, proxy: Telnet_proxy, path: str = '/sys/board/chip/soc/axi_ico'):
        self.proxy = proxy
        self.component = proxy._get_component(path)

    def mem_write(self, addr: int, size: int, values: bytes):
        """Inject a memory write.

        The access is generated by the router where this class is connected and is
        injected as a debug request to not disturb the timing.

        Parameters
        ----------
        addr : int
            The address of the access.
        size : int
            The size of the access in bytes.
        values : bytes
            The sequence of bytes to be written, in little endian byte ordering.

        Raises
        ------
        RuntimeError
            If the access generates an error in the architecture.
        """
        cmd = 'component %s mem_write 0x%x 0x%x' % (self.component, addr, size)

        for byte in values:
            cmd += ' 0x%x' % byte

        cmd += '\n'

        self.proxy.telnet.write(cmd.encode('ascii'))

        self.proxy._get_retval()

    def mem_read(self, addr: int, size: int) -> bytes:
        """Inject a memory read.

        The access is generated by the router where this class is connected and is
        injected as a debug request to not disturb the timing.

        Parameters
        ----------
        addr : int
            The address of the access.
        size : int
            The size of the access in bytes.

        Returns
        -------
        bytes
            The sequence of bytes read, in little endian byte ordering.

        Raises
        ------
        RuntimeError
            If the access generates an error in the architecture.
        """
        cmd = 'component %s mem_read 0x%x 0x%x\n' % (self.component, addr, size)
        self.proxy.telnet.write(cmd.encode('ascii'))
        result = self.proxy.telnet.read_until(b"\n")
        reply = result.decode('ascii').replace('\n', '')
        values_str, err = reply.split(' ;')

        self.proxy._handle_err(int(err.split('=')[1]))

        values = bytearray()

        for value_str in values_str.split(' '):
            values += int(value_str).to_bytes(1, byteorder="little")

        return values

    def mem_write_int(self, addr: int, size: int, value: int):
        """Write an integer.

        The access is generated by the router where this class is connected and is
        injected as a debug request to not disturb the timing.

        Parameters
        ----------
        addr : int
            The address of the access.
        size : int
            The size of the access in bytes.
        value : int
            The integer to be written.

        Raises
        ------
        RuntimeError
            If the access generates an error in the architecture.
        """
        return self.mem_write(addr, size, value.to_bytes(size, byteorder='little'))

    def mem_read_int(self, addr: int, size: int) -> int:
        """Read an integer.

        The access is generated by the router where this class is connected and is
        injected as a debug request to not disturb the timing.

        Parameters
        ----------
        addr : int
            The address of the access.
        size : int
            The size of the access in bytes.

        Returns
        -------
        int
            The integer read.

        Raises
        ------
        RuntimeError
            If the access generates an error in the architecture.
        """
        values = self.mem_read(addr, size)
        return int.from_bytes(values, byteorder='little')




class Testbench(object):
    """Testbench class.

    This class can be instantiated to get access to the testbench.

    Attributes
    ----------
    proxy : Telnet_proxy
        The proxy object. This class will use it to send command to GVSOC through the proxy connection.
    path : string, optional
        The path to the testbench in the architecture.
    """

    def __init__(self, proxy: Telnet_proxy, path: str = '/sys/board/testbench/testbench'):
        self.proxy = proxy
        self.component = proxy._get_component(path)


    def i2s_get(self, id: int = 0):
        """Open an SAI.

        Opena an SAI and return and object which can be used to interact with it.

        Parameters
        ----------
        id : int, optional
            The SAI identifier.

        Returns:
        Testbench_i2s
            An object which can be used to access the specified SAI.
        """
        return Testbench_i2s(self.proxy, self.component, id)



class Testbench_i2s(object):
    """Class instantiated for each manipulated SAI.

    It can used to interact with the SAI, like injecting streams.

    Attributes
    ----------
        proxy : Telnet_proxy
            The proxy object. This class will use it to send command to GVSOC through the proxy connection.
        testbench : int
            The testbench object.
        id : int, optional
            The identifier of the SAI interface.
    """

    def __init__(self, proxy: Telnet_proxy, testbench: Testbench, id=0):
        self.id = id
        self.proxy = proxy
        self.testbench = testbench

    def open(self, word_size: int = 16, sampling_freq: int = -1, nb_slots: int = 1, is_pdm: bool = False,
            is_full_duplex: bool = False, is_ext_clk: bool = False, is_ext_ws: bool = False, is_sai0_clk: bool = False,
            is_sai0_ws: bool = False, clk_polarity: int = 0, ws_polarity: int = 0):
        """Open and configure SAI.

        Parameters
        ----------
        word_size : int, optional
            Specify the frame word size in bits.
        sampling_freq : int, optional
            Specify the sampling frequency. This is used either to generate the clock when
            it is external or to check that internally generated one is correct.
        nb_slots : int, optional
            Number of slots in the frame.
        is_pdm : bool, optional
            True if the stream is a PDM stream.
        is_full_duplex : bool, optional
            True if the SAI is used in full duplex mode.
        is_ext_clk: bool, optional
            True is the clock is generated by the testbench.
        is_ext_ws: bool, optional
            True is the word strobe is generated by the testbench.
        is_sai0_clk: bool, optional
            True is the the clock should be taken from SAI0.
        is_sai0_ws: bool, optional
            True is the the word strobe should be taken from SAI0.
        clk_polarity : int, optional
            Clock polarity, definition is the same as SAI0 specifications.
        ws_polarity : int, optional
            Word strobe polarity, definition is the same as SAI0 specifications.

        Raises
        ------
        RuntimeError
            If there is any invalid parameter.
        """

        options = ''
        options += ' itf=%d' % self.id
        options += ' enabled=1'
        options += ' sampling_freq=%d' % sampling_freq
        options += ' word_size=%d' % word_size
        options += ' nb_slots=%d' % nb_slots
        options += ' is_pdm=%d' % is_pdm
        options += ' is_full_duplex=%d' % is_full_duplex
        options += ' is_ext_clk=%d' % is_ext_clk
        options += ' is_ext_ws=%d' % is_ext_ws
        options += ' is_sai0_clk=%d' % is_sai0_clk
        options += ' is_sai0_ws=%d' % is_sai0_ws
        options += ' clk_polarity=%d' % clk_polarity
        options += ' ws_polarity=%d' % ws_polarity
        cmd = 'component %s i2s setup %s\n' % (self.testbench, options)
        self.proxy.telnet.write(cmd.encode('ascii'))
        self.proxy._get_retval()

    def close(self):
        """Close SAI.
    
        Raises
        ------
        RuntimeError
            If there is any error while closing.
        """
        options = ''
        options += ' itf=%d' % self.id
        options += ' enabled=0'
        cmd = 'component %s i2s setup %s\n' % (self.testbench, options)
        self.proxy.telnet.write(cmd.encode('ascii'))
        self.proxy._get_retval()

    def clk_start(self):
        """Start clock.

        This can be used when the clock is generated by the testbench to start the generation.

        Raises
        ------
        RuntimeError
            If there is any error while starting the clock.
        """
        cmd = 'component %s i2s clk_start %d\n' % (self.testbench, self.id)
        self.proxy.telnet.write(cmd.encode('ascii'))
        self.proxy._get_retval()

    def clk_stop(self):
        """Stop clock.

        This can be used when the clock is generated by the testbench to stop the generation.

        Raises
        ------
        RuntimeError
            If there is any error while stopping the clock.
        """
        cmd = 'component %s i2s clk_stop %d\n' % (self.testbench, self.id)
        self.proxy.telnet.write(cmd.encode('ascii'))
        self.proxy._get_retval()

    def slot_open(self, slot: int = 0, is_rx: bool = True, word_size: int = 16, is_msb: bool = True,
            sign_extend: bool = False, left_align: bool = False):
        """Open and configure a slot.

        Parameters
        ----------
        slot : int, optional
            Slot identifier
        is_rx : bool, optional
            True if gap receives the samples.
        word_size : int, optional
            Slot width in number of bits.
        is_msb : bool, optional
            True if the samples are received or sent with MSB first.
        sign_extend : bool, optional
            True if the samples are sign-extended.
        left_align : bool, optional
            True if the samples are left aligned.

        Raises
        ------
        RuntimeError
            If there is any invalid parameter.
        """
        options = ''
        options += ' itf=%d' % self.id
        options += ' slot=%d' % slot
        options += ' is_rx=%d' % is_rx
        options += ' enabled=1'
        options += ' word_size=%d' % word_size
        options += ' format=%d' % (is_msb | (left_align << 1) | (sign_extend << 1))
        cmd = 'component %s i2s slot_setup %s\n' % (self.testbench, options)
        self.proxy.telnet.write(cmd.encode('ascii'))
        self.proxy._get_retval()

    def slot_close(self, slot: int = 0):
        """Close a slot.

        Parameters
        ----------
        slot : int, optional
            Slot identifier

        Raises
        ------
        RuntimeError
            If there is any invalid parameter.
        """
        options = ''
        options += ' itf=%d' % self.id
        options += ' slot=%d' % slot
        options += ' enabled=0'
        cmd = 'component %s i2s slot_setup %s\n' % (self.testbench, options)
        self.proxy.telnet.write(cmd.encode('ascii'))
        self.proxy._get_retval()

    def slot_rx_file_reader(self, slot: int = 0, filetype: str = "wav", filepath: str = None):
        """Read a stream of samples from a file.

        This will open a file and stream it to the SAI so that gap receives the samples

        Parameters
        ----------
        slot : int, optional
            Slot identifier
        filetype : string, optional
            Describes the type of the file, can be "wav" or "au".
        filepath : string, optional
            Path to the file.

        Raises
        ------
        RuntimeError
            If there is any invalid parameter.
        """
        options = ''
        options += ' itf=%d' % self.id
        options += ' slot=%d' % slot
        options += ' filetype=%s' % filetype
        options += ' filepath=%s' % filepath
        cmd = 'component %s i2s slot_rx_file_reader %s\n' % (self.testbench, options)
        self.proxy.telnet.write(cmd.encode('ascii'))
        self.proxy._get_retval()

    def slot_tx_file_dumper(self, slot: int = 0, filetype: str = "wav", filepath: str = None):
        """Write a stream of samples to a file.

        This will open a file and write to it all the samples received from gap

        Parameters
        ----------
        slot : int, optional
            Slot identifier
        filetype : string, optional
            Describes the type of the file, can be "wav" or "au".
        filepath : string, optional
            Path to the file.

        Raises
        ------
        RuntimeError
            If there is any invalid parameter.
        """
        options = ''
        options += ' itf=%d' % self.id
        options += ' slot=%d' % slot
        options += ' filetype=%s' % filetype
        options += ' filepath=%s' % filepath
        cmd = 'component %s i2s slot_tx_file_dumper %s\n' % (self.testbench, options)
        self.proxy.telnet.write(cmd.encode('ascii'))
        self.proxy._get_retval()

    def slot_stop(self, slot: int = 0, stop_rx: bool = True, stop_tx: bool = True):
        """Stop a slot.

        This will stop the streamings (file reader or dumper) configured on the specified slot.

        Parameters
        ----------
        slot : int, optional
            Slot identifier
        stop_rx : bool, optional
            Stop the stream sent to gap.
        stop_tx : bool, optional
            Stop the stream received from gap.

        Raises
        ------
        RuntimeError
            If there is any invalid parameter.
        """
        options = ''
        options += ' itf=%d' % self.id
        options += ' slot=%d' % slot
        options += ' stop_rx=%d' % stop_rx
        options += ' stop_tx=%d' % stop_tx
        cmd = 'component %s i2s slot_stop %s\n' % (self.testbench, options)
        self.proxy.telnet.write(cmd.encode('ascii'))
        self.proxy._get_retval()
